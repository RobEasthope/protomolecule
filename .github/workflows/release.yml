name: Continuous Release

on:
  push:
    branches:
      - main

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  release:
    name: 🚀 Continuous Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      pull-requests: write
      issues: read
    steps:
      - name: ⬇️ Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Use PAT if available, otherwise GITHUB_TOKEN
          # PAT needs: repo scope for pushing to protected branches
          token: ${{ secrets.RELEASE_PAT || secrets.GITHUB_TOKEN }}

      - name: 🔧 Setup Monorepo
        uses: ./.github/actions/setup-monorepo

      - name: 🏗️ Build packages
        run: |
          pnpm build
          
          # Verify build outputs for publishable packages
          if [ -f "packages/eslint-config/package.json" ]; then
            if [ ! -f "packages/eslint-config/dist/index.js" ]; then
              echo "❌ Build failed: ESLint config dist/index.js not found"
              exit 1
            fi
          fi
          
          if [ -f "packages/tsconfig/package.json" ]; then
            PKG_PRIVATE=$(node -p "require('./packages/tsconfig/package.json').private")
            if [ "$PKG_PRIVATE" = "false" ]; then
              # Check for expected output files if tsconfig becomes public
              echo "✅ TSConfig package build verified"
            fi
          fi
          
          echo "✅ Build verification passed"

      - name: 📋 Check for changesets
        id: changesets-check
        run: |
          # Check for changeset files, excluding README.md and config.json
          CHANGESET_COUNT=$(find .changeset -name "*.md" -not -name "README.md" 2>/dev/null | wc -l)
          
          if [ "$CHANGESET_COUNT" -gt 0 ]; then
            echo "has_changesets=true" >> $GITHUB_OUTPUT
            echo "Found $CHANGESET_COUNT changeset file(s) to process"
            # List the changesets for visibility
            find .changeset -name "*.md" -not -name "README.md" -exec basename {} \;
          else
            echo "has_changesets=false" >> $GITHUB_OUTPUT
            echo "No changeset files found (excluding README.md)"
          fi

      - name: 🔄 Process changesets and version
        if: steps.changesets-check.outputs.has_changesets == 'true'
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Version packages based on changesets
          pnpm changeset version

          # Commit version bumps
          git add -A
          git commit -m "chore: version packages [skip ci]" || echo "No changes to commit"

      - name: 🚀 Publish to NPM
        if: steps.changesets-check.outputs.has_changesets == 'true'
        id: publish
        run: |
          # Publish packages
          set +e  # Don't exit on error
          pnpm changeset publish > publish-output.txt 2>&1
          PUBLISH_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Check if publish was successful
          if [ $PUBLISH_EXIT_CODE -eq 0 ] && grep -q "Publishing" publish-output.txt; then
            echo "published=true" >> $GITHUB_OUTPUT
            echo "publish_success=true" >> $GITHUB_OUTPUT
            cat publish-output.txt
          else
            echo "published=false" >> $GITHUB_OUTPUT
            echo "publish_success=false" >> $GITHUB_OUTPUT
            echo "⚠️ NPM publish failed or no packages to publish"
            cat publish-output.txt
            # Don't fail the workflow, but mark as unsuccessful
          fi
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          HUSKY: 0

      - name: 📝 Push version commits
        if: steps.changesets-check.outputs.has_changesets == 'true' && steps.publish.outputs.publish_success == 'true'
        run: |
          git push origin main

      - name: 🏷️ Create GitHub Release
        if: steps.publish.outputs.published == 'true'
        run: |
          # Dynamically find all published packages and their versions
          RELEASE_INFO=$(node -p "
            const fs = require('fs');
            const path = require('path');
            
            // Find all package.json files in packages directory
            const packagesDir = 'packages';
            const packages = [];
            
            if (fs.existsSync(packagesDir)) {
              const dirs = fs.readdirSync(packagesDir);
              for (const dir of dirs) {
                const pkgPath = path.join(packagesDir, dir, 'package.json');
                if (fs.existsSync(pkgPath)) {
                  try {
                    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
                    if (!pkg.private) {
                      packages.push({
                        name: pkg.name,
                        version: pkg.version
                      });
                    }
                  } catch (e) {
                    console.error('Error reading ' + pkgPath + ': ' + e.message);
                  }
                }
              }
            }
            
            // If we found packages, use the highest version (with proper semver sorting)
            // Otherwise fall back to a timestamp-based version
            if (packages.length > 0) {
              const versions = packages.map(p => p.version);
              // Proper semver sorting
              const highest = versions.sort((a, b) => {
                const [aMajor, aMinor, aPatch] = a.split('.').map(Number);
                const [bMajor, bMinor, bPatch] = b.split('.').map(Number);
                if (aMajor !== bMajor) return bMajor - aMajor;
                if (aMinor !== bMinor) return bMinor - aMinor;
                return bPatch - aPatch;
              })[0]; // Take first (highest) after reverse sort
              const pkgList = packages.map(p => p.name + '@' + p.version).join(', ');
              JSON.stringify({ version: highest, packages: pkgList, packageData: packages });
            } else {
              const date = new Date().toISOString().split('T')[0];
              JSON.stringify({ version: date, packages: 'No packages published', packageData: [] });
            }
          ")
          
          # Parse the release info
          VERSION=$(echo "$RELEASE_INFO" | node -p "JSON.parse(require('fs').readFileSync(0, 'utf8')).version")
          PACKAGES=$(echo "$RELEASE_INFO" | node -p "JSON.parse(require('fs').readFileSync(0, 'utf8')).packages")
          PACKAGE_DATA=$(echo "$RELEASE_INFO" | node -p "JSON.stringify(JSON.parse(require('fs').readFileSync(0, 'utf8')).packageData)")
          
          # Generate user-friendly release summary
          USER_SUMMARY=$(PUBLISHED_PACKAGES="$PACKAGE_DATA" node scripts/generate-release-summary.js 2>/dev/null || echo "")
          
          # Build release notes
          if [ -n "$USER_SUMMARY" ]; then
            RELEASE_NOTES="$USER_SUMMARY

## 📦 Technical Details

Published packages: $PACKAGES"
          else
            RELEASE_NOTES="## 🚀 Automated Release

Published packages: $PACKAGES

Generated by continuous deployment workflow."
          fi
          
          # Create release with enhanced notes
          gh release create "v$VERSION" \
            --title "v$VERSION" \
            --notes "$RELEASE_NOTES" \
            --target main
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 📊 Generate Summary
        if: always()
        run: |
          echo "## 🚀 Continuous Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.changesets-check.outputs.has_changesets }}" == "true" ]; then
            if [ "${{ steps.publish.outputs.publish_success }}" == "true" ]; then
              echo "✅ Changesets processed and packages published successfully" >> $GITHUB_STEP_SUMMARY
            else
              echo "⚠️ Changesets processed but NPM publishing failed" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Action Required:** Check NPM_TOKEN and package configuration" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ -f publish-output.txt ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### Publishing Output" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              cat publish-output.txt >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "ℹ️ No changesets found - no release needed" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "_Workflow triggered by: ${{ github.actor }}_" >> $GITHUB_STEP_SUMMARY
